{
    "BEGIN": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nBEGIN filename [ nonPausing ] state list\n```\nBEGIN tells WeiDU that you are creating a new DLG file from scratch. Any existing DLG file with the same name will be overwritten. The new DLG file contains exactly the states in the list. If you set nonPausing to a non-zero integer, the game will not \"stop time\" while the conversation takes place. By default time stops during conversations."
        }
    },
    "APPEND": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nAPPEND [ IF_FILE_EXISTS ] filename state list END\n```\nThis tells WeiDU to place the given states at the end of the already-existing dialogue filename.DLG. If there is IF_FILE_EXISTS and the file doesn't exists, this action is skipped."
        }
    },
    "APPEND_EARLY": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nAPPEND_EARLY [ IF_FILE_EXISTS ] filename state list END\n```\nWorks like APPEND, but the states are added early on in the compilation timeline (just after BEGIN is processed). Thus they can be the targets for INTERJECT_COPY_TRANS and friends."
        }
    },
    "CHAIN": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nCHAIN [ IF [ WEIGHT #weight ] stateTriggerString THEN ] [ IF_FILE_EXISTS ] entryFilename entryLabel chainText list chainEpilogue\n```\nThis instructs WeiDU to make a long conversation in which the PC can say nothing. This is useful when you want the NPCs to talk among themselves for a long time. It and its friends, INTERJECT and INTERJECT_COPY_TRANS can incredible time-savers when you're writing non-trivial dialogue. See the examples for ideas. CHAIN will only append to existing dialogues. You cannot use CHAIN to create a new DLG. If the entryFilename file is missing and there is IF_FILE_EXISTS, the whole CHAIN is not compiled."
        }
    },
    "INTERJECT": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nINTERJECT entryFilename entryLabel globalVariable chainText list chainEpilogue\n```\nBehaves like CHAIN except that all of the chainText is additionally guarded by the transition predicate Global(\"globalVariable\",\"GLOBAL\",0) and accompanied by the action SetGlobal(\"globalVariable\",\"GLOBAL\",1). If you pick globalVariable to be unique, this will ensure that the chainText is only ever seen once per game. This is useful for making interjections."
        }
    },
    "INTERJECT_COPY_TRANS": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nINTERJECT_COPY_TRANS [ SAFE ] entryFilename entryLabel globalVariable chainText list\n```\nThis behaves just like INTERJECT except that the exitFilename and exitLabel are not present. Instead, whenever the dialogue would pass out of the chainText it follows a copy of the transitions that were at the state with stateLabel originally. This is convenient for making quick interjections from NPCs that do not actually change the true flow of the conversation. See the transition COPY_TRANS and the INTERJECT_COPY_TRANS tutorial for more information about this idea. If SAFE is specified, INTERJECT_COPY_TRANS will not warn about potentially unsafe uses (use this if you know it is safe)."
        }
    },
    "INTERJECT_COPY_TRANS2": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nINTERJECT_COPY_TRANS2 [ SAFE ] entryFilename entryLabel globalVariable chainText list\n```\nThis works just like INTERJECT_COPY_TRANS, except that any actions taken in the transitions of the state specified by entryFilename and entryLabel are preserved and kept with the speaker associated with entryFilename (rather than being mistakenly performed by your new speaker). See the INTERJECT_COPY_TRANS2 tutorial."
        }
    },
    "INTERJECT_COPY_TRANS3": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nINTERJECT_COPY_TRANS3 [ SAFE ] entryFilename entryLabel globalVariable chainText list\n```\nThis works just like INTERJECT_COPY_TRANS, except that all states in chainText get a link in the entry state, rather than only the first one. Expecting documentation."
        }
    },
    "INTERJECT_COPY_TRANS4": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nINTERJECT_COPY_TRANS4 [ SAFE ] entryFilename entryLabel globalVariable chainText list\n```\nThis is either INTERJECT_COPY_TRANS3 with INTERJECT_COPY_TRANS2-style action handling, or INTERJECT_COPY_TRANS2 with the extended INTERJECT_COPY_TRANS3 state creation rules, depending at how you look at it."
        }
    },
    "EXTEND_TOP": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nEXTEND_TOP filename stateLabel list [ #positionNumber ] transition list END\n```\nThis instructs WeiDU to add the transitions in list to the top of the transition list for the specified states in filename.DLG (which must already exist).If a positionNumber is given, WeiDU to insert the transitions just between already-existing transitions #positionNumber and #positionNumber+1 in the given states for the given file. The first transition is number 1."
        }
    },
    "EXTEND_BOTTOM": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nEXTEND_BOTTOM filename stateNumber list [ #positionNumber ] transition list END\n```\nBehaves just like EXTEND_TOP but adds the transitions to the bottom of the list instead."
        }
    },
    "ADD_STATE_TRIGGER": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nADD_STATE_TRIGGER filename stateNumber stateTriggerString [ stateNumber list ] \tdActionWhen list\n```\nThis instructs WeiDU to add the stateTriggerString to all of the states with the given stateNumbers in the file filename.DLG (which must already exist). This is handy for adding extra conditions to an existing dialogue state."
        }
    },
    "ADD_TRANS_TRIGGER": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nADD_TRANS_TRIGGER filename stateNumber transTriggerString [ moreStateNumbers list ] [ DO transNumber list ] dActionWhen list\n```\nThis instructs WeiDU to add the transTriggerString to all of the transitions in all of the states with the given stateNumbers in the file filename.DLG (which must already exist). This is often used in conjunction with EXTEND_BOTTOM to make a new branch in an existing state. Use ADD_TRANS_TRIGGER to add the negation of some predicate to all of the existing transitions, then use EXTEND_BOTTOM to add a transition with that predicate to that state. If a list of transNumbers is specified, only those transitions will have transTriggerString added to them. If such a list is not specified, every transition in every specified state will be modified. Note that the \"first\" transition is number 0."
        }
    },
    "ADD_TRANS_ACTION": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nADD_TRANS_ACTION filename BEGIN stateNumber list END BEGIN transNumber list END transActionString dActionWhen list\n```\nThis instructs WeiDU to add the transActionString to all of the actions in all the transitions in all of the states specified by the stateNumber list and the transNumber list. You may use state labels in the stateNumber list. If the transNumber list is empty, the text added to all transitions on all listed states. Note that the BEGIN and END keywords must be present, even if you specify an empty list of transNumbers. The \"first\" transition is number 0. Any out-of-bounds transNumbers are silently ignored. The transActionString is prepended to any existing action text on a per-transition, per-state basis."
        }
    },
    "REPLACE_TRANS_ACTION": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLACE_TRANS_ACTION filename BEGIN stateNumber list END BEGIN transNumber list END oldText newText dActionWhen list\n```\nThis instructs WeiDU to replace all instances of oldText in newText to all of the actions in all the transitions in all of the states specified by the stateNumber list and the transNumber list. You may use state labels in the stateNumber list. If the transNumber list is empty, the text added to all transitions on all listed states. Note that the BEGIN and END keywords must be present, even if you specify an empty list of transNumbers. The \"first\" transition is number 0. Any out-of-bounds transNumbers are silently ignored."
        }
    },
    "REPLACE_TRANS_TRIGGER": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLACE_TRANS_TRIGGER filename BEGIN stateNumber list END BEGIN transNumber list END oldText newText dActionWhen list\n```\nThis instructs WeiDU to replace all instances of oldText in newText to all of the triggers in all of the transitions in all of the states specified by the stateNumber list and the transNumber list. You may use state labels in the stateNumber list. If the transNumber list is empty, the text added to all transitions on all listed states. Note that the BEGIN and END keywords must be present, even if you specify an empty list of transNumbers. The \"first\" transition is number 0. Any out-of-bounds transNumbers are silently ignored."
        }
    },
    "ALTER_TRANS": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nALTER_TRANS filename BEGIN stateNumber list END BEGIN transNumber list END BEGIN changeWhat changeInto list END\n```\nFine altering of a single transition. See the ALTER_TRANS tutorial."
        }
    },
    "REPLACE": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLACE filename state list END\n```\nThis instructs WeiDU to load filename.DLG and replace some of its states with the new ones described in the state list. All of the states should have numeric stateLabels (e.g., \"5\" or \"67\"). A new state with label X will replace the old state number X."
        }
    },
    "SET_WEIGHT": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nSET_WEIGHT filename stateLabel #stateWeight\n```\nThis instructs WeiDU to destructively change the WEIGHT of the given state in filename.DLG (which must exist). This should only be used to patch or workaround existing dialogues. Never use SET_WEIGHT if you can help it."
        }
    },
    "REPLACE_SAY": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLACE_SAY filename stateLabel sayText\n```\nThis instructs WeiDU to destructively change the sayText of the given state in filename.DLG (which must exist). This should only be used to patch or workaround existing dialogues. Never use REPLACE_SAY if you can help it."
        }
    },
    "REPLACE_STATE_TRIGGER": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLACE_STATE_TRIGGER filename stateNumber stateTriggerString [ stateNumber list ] \tdActionWhen list\n```\nThis instructs WeiDU to destructively set the stateTriggerString of all of the states with the given stateNumbers in the file filename.DLG (which must already exist). It should be used with caution."
        }
    },
    "REPLACE_TRIGGER_TEXT": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLACE_TRIGGER_TEXT filename oldText newText dActionWhen list\n```\nThis instructs WeiDU to destructively replace every occurrence of oldText (which may be a regexp) in the stateTriggerStrings and transTriggerStrings of filename.DLG (which must exist). This should only be used to patch or workaround existing dialogues. Never use this if you can help it."
        }
    },
    "REPLACE_TRIGGER_TEXT_REGEXP": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLACE_TRIGGER_TEXT_REGEXP filenameRegexp oldText newText dActionWhen list\n```\nJust like REPLACE_TRIGGER_TEXT but the filename is a regexp. The .DLG is implied."
        }
    },
    "REPLACE_ACTION_TEXT": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLACE_ACTION_TEXT filename oldText newText [ moreFilenames ] dActionWhen list\n```\nThis instructs WeiDU to destructively replace every occurrence of oldText (which may be a regexp) in the stateActionStrings of filename.DLG (which must exist). This should only be used to patch or workaround existing dialogues. Never use this if you can help it."
        }
    },
    "REPLACE_ACTION_TEXT_REGEXP": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLACE_ACTION_TEXT_REGEXP filenameRegexp oldText newText [ moreFilenameRegexps ] dActionWhen list\n```\nJust like REPLACE_ACTION_TEXT but the filenames are regexps. The .DLG is implied, do not include it in your regexps."
        }
    },
    "REPLACE_ACTION_TEXT_PROCESS": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLACE_ACTION_TEXT_PROCESS filename oldText newText [ moreFilenames ] dActionWhen list\n```\nThis instructs WeiDU to destructively replace every occurrence of oldText (which may be a regexp) in the stateActionStrings of filename.DLG (which must exist) with newText. However, newText is first compiled as a BAF action list. In particular, this means that replacing with commands like: ~DisplayString(Myself,@123)~ ... will do what you expect. This should only be used to patch or workaround existing dialogues. Never use this if you can help it."
        }
    },
    "R_A_T_P_R": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nR_A_T_P_R filenameRegexp oldText newText [ moreFilenameRegexps ] dActionWhen list\n```\nJust like REPLACE_ACTION_TEXT_PROCESS, but the filenames are regexps. The .DLG is implied. R_A_T_P_R is shorthand for REPLACE_ACTION_TEXT_PROCESS_REGEXP (to avoid undue scrollbars in the readme on a 1024x768 monitor)."
        }
    },
    "IF": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nIF transTriggerString [ THEN ] transFeature list transNext\n```\nIf the transTriggerString evaluates to true or is empty, this transition is viable. If it contains no replyText within its transFeature list, it is immediately taken. Otherwise, the replyText is presented as an option to the user. If the transition is taken, any actions in the transFeature list are performed and the dialogue flows to the point indicated by the transNext. transitions are evaluated in \"reverse order\". That is, the \"bottom\" or \"last\" response for a state is checked first. If its transTriggerString evaluates to true and it has no REPLY text, that transition is immediately taken. See SAREV25A state 1 for an example of a state with all kinds of transitions."
        }
    },
    "UNLESS": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nUNLESS String\n```\nThe action is not processed if the element being altered/replaced/added to contains a substring matching against the String regexp."
        }
    },
    "END": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nEND transition list\n```\nExecute the given transitions after the final state in the CHAIN."
        }
    },
    "EXTERN": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nEXTERN [ IF_FILE_EXISTS ] filename stateLabel\n```\nThe dialogue continues at the state with label stateLabel in the file filename.DLG. The whole transition is not compiled if there's IF_FILE_EXISTS and the file filename doesn't exist."
        }
    },
    "COPY_TRANS": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nCOPY_TRANS [ SAFE ] filename stateLabel\n```\nThis instructs WeiDU to copy all of the transitions from the state with the given stateLabel in filename.DLG. This copying takes place before all other D Actions. For example, this is a valid transition list: IF ~Before()~ THEN GOTO my_state COPY_TRANS PLAYER1 33 IF ~After()~ THEN EXTERN SOLA 55 If SAFE is specified, COPY_TRANS will not warn about potentially unsafe uses (use this if you know it is safe)."
        }
    },
    "COPY_TRANS_LATE": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nCOPY_TRANS_LATE [ SAFE ] filename stateLabel\n```\nSame as COPY_TRANS, but is invoked after all other D Actions."
        }
    },
    "EXIT": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nEXIT\n```\nThe conversation ends."
        }
    },
    "APPENDI": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nAPPENDI filename state list END\n```\nThis is legacy syntax that behaves just like the D Action APPEND but is considered a state. Avoid it."
        }
    },
    "CHAIN2": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nCHAIN2 entryFilename entryLabel chain2Text list exitFilename exitLabel\n```\nThis is legacy syntax that behaves somewhat like the D Action CHAIN but is considered a state. In addition, chain2Text is slightly different from chainText. Avoid this construction."
        }
    },
    "text": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\ntext\n```\nsayText and replyText are both text."
        }
    },
    "+": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\n+ stateLabel\n```\nThis is a synonym for GOTO."
        }
    },
    "REPLY": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nREPLY replyText\n```\nIf this transition is taken, the PC says the replyText."
        }
    },
    "DO": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nDO stateActionString\n```\nIf this transition is taken, the stateActionString is executed."
        }
    },
    "JOURNAL": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nJOURNAL text\n```\nIf this transition is taken, the text is added to the PC's journal."
        }
    },
    "SOLVED_JOURNAL": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nSOLVED_JOURNAL text\n```\nIf this transition is taken, the text is added to the \"solved\" section of the PC's journal."
        }
    },
    "UNSOLVED_JOURNAL": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nUNSOLVED_JOURNAL text\n```\nIf this transition is taken, the text is added to the \"unsolved\" section of the PC's journal."
        }
    },
    "FLAGS": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nFLAGS integer\n```\nThis allows you to set the features associated with a transition directly using the binary format of DLG files."
        }
    },
    "GOTO": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nGOTO stateLabel\n```\nThe dialogue continues at the state with label stateLabel in the same DLG file as the current state."
        }
    },
    "[": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\n[ == [ IF_FILE_EXISTS ] fileName [ IF transTriggerString THEN ] sayText = sayText ... ]\n```\nThe == (that's two consecutive equal signs) marks the beginning of a new speaker (indicated by fileName). If the transTriggerString is true or if it is not present, this new speaker says all of its sayText in order. If the IF_FILE_EXISTS part is present, these lines are not compiled at all if the current file is not missing."
        }
    },
    "BRANCH": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nBRANCH transTriggerString BEGIN [ == [ IF_FILE_EXISTS ] fileName [ IF transTriggerString THEN ] sayText = sayText ... ] END\n```\nAs above, except that the first transTriggerString is appended to all existing dialogue units."
        }
    },
    "String": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nString ^ String\n```\nString literal concatenation. The second string is appended to the first string. No whitespace is added. Thus \"hello\" ^ \"World\" is the same as \"helloWorld\"."
        }
    },
    "!integer": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\n!integer text\n```\nForced String Reference. As with text in general, but rather than being assigned a new, previously-unused DIALOG.TLK string entry (or merging with an existing one that has the same text), this text is written over DIALOG.TLK string entry #integer. Do not use this without a real reason."
        }
    },
    "reference": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\nreference\n```"
        }
    },
    "#integer": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\n#integer\n```\nThe string with reference number #integer from DIALOG.TLK should be used unchanged."
        }
    },
    "@integer": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\n@integer\n```\nThe last definition of the translation string @integer given in any TRA file should be used."
        }
    },
    "(": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\n( AT \"var\" )\n```\nThe last definition of the translation string (with value defined by a variable) given in any TRA file should be used."
        }
    },
    "\"abcdef\"": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\n\"abcdef\"\n```\nA string can be any sequence of characters not including a \" that is enclosed in \"\"s."
        }
    },
    "~abcdef~": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\n~abcdef~\n```\nA string can be any sequence of characters not including a ~ that is enclosed in ~~s."
        }
    },
    "%abcdef%": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\n%abcdef%\n```\nA string can be any sequence of characters not including a % that is enclosed in %%s. This is handy for Big5 translations, since \" and ~ can be part of Big5-encoded characters."
        }
    },
    "~~~~~abcdef~~~~~": {
        "contents": {
            "kind": "markdown",
            "value": "```weidu-d\n~~~~~abcdef~~~~~\n```\nThat's five consecutive tildes on each side. A string can be any sequence of characters not including ~~~~~ that is enclosed in ~~~~~s. For example, string #8750 is ~!@#$\\%^&*()_+-=[]{}\\|;:'\",<.>/? and can be given to WeiDU as ~~~~~~!@#$\\%^&*()_+-=[]{}\\|;:'\",<.>/?~~~~~ (the content of the string is shown in red for clarity)."
        }
    }
}